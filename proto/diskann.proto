// Copyright (c) 2023 dingodb.com, Inc. All Rights Reserved
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

import "common.proto";
import "error.proto";
import "store.proto";
import "index.proto";

package dingodb.pb.diskann;

option java_package = "io.dingodb.diskann";

option cc_generic_services = true;

message VectorNewRequest {
  dingodb.pb.common.RequestInfo request_info = 1;
  // vector index ID is equivalent to region_id
  int64 vector_index_id = 2;

  dingodb.pb.common.VectorIndexParameter vector_index_parameter = 3;

  //  (default is to get_omp_num_procs()): number of threads used by the index build process. Since the code is highly
  //  parallel, the indexing time improves almost linearly with the number of threads (subject to the cores available on
  //  the machine and DRAM bandwidth).
  // This parameter is intrusive and must be set consistently across all threads.
  // It cannot be set to 0. It is recommended to set it to a maximum of cpus/2. required
  // uint32 num_threads = 4;

  // bound on the memory footprint of the index at search time in GB. Once built, the index will use up only the
  // specified RAM limit, the rest will reside on disk. This will dictate how aggressively we compress the data vectors
  // to store in memory. Larger will yield better performance at search time. For an n point index, to use b byte PQ
  // compressed representation in memory, use search_DRAM_budget_gb = ((n * b) / 2^30  + (250000*(4*R + sizeof(T)*ndim))
  // / 2^30). The second term in the summation is to allow some buffer for caching about 250,000 nodes from the graph in
  // memory while serving. If you are not sure about this term, add 0.25GB to the first term. At least 1.25G is
  // recommended. From the code, n * dim bytes is the best. required
  // float search_dram_budget_gb = 6;

  // Limit on the memory allowed for building the index in GB. If you specify a value less than what is required to
  // build the index in one pass, the index is built using a divide and conquer approach so that sub-graphs will fit in
  // the RAM budget. The sub-graphs are overlayed to build the overall index. This approach can be upto 1.5 times slower
  // than building the index in one shot. Allocate as much memory as your RAM allows.
  // This is a very important parameter!!!
  // This is a very important parameter!!!
  // This is a very important parameter!!!
  // It determines the build speed. Do it well to build successfully in onego.
  // double size_of_data = ((double)size) * ROUND_UP(dim, 8) * sizeof(float);
  // double size_of_graph =   // ((double)size) * degree * sizeof(uint32_t) * 1.3;
  // double size_of_locks = ((double)size) * sizeof(std::mutex);
  // double size_of_outer_vector = ((double)size) * sizeof(ptrdiff_t);
  // return 1.1 * (size_of_data + size_of_graph + size_of_locks + size_of_outer_vector); required
  // float build_dram_budget_gb = 7;

  // The input data over which to build an index, in .bin format. The first 4 bytes represent number of points as an
  // integer. The next 4 bytes represent the dimension of data as an integer. The following n*d*sizeof(T) bytes contain
  // the contents of the data one data point in time. sizeof(T) is 1 for byte indices, and 4 for float indices.
  // This will be read by the program as int8_t for signed indices, uint8_t for unsigned indices or float for
  // float indices.
  // There are a few points to note:
  // 1. This file path does not need to exist, it is automatically generated by the background program.
  // 2. The number of vectors cannot exceed the maximum value of uint32 (0xFFFFFFFF), otherwise an error will be
  // reported.
  // 3. The parent directory of this file must have write permission, otherwise the program creation will fail
  // such as : /home/user/work/dingo_512_100000.bin . required
  // string data_path = 8;

  // The index will span a few files, all beginning with the specified prefix path. For example, if you provide
  // ~/index_test as the prefix path, build generates files such as ~/index_test_pq_pivots.bin,
  // ~/index_test_pq_compressed.bin, ~/index_test_disk.index, .... There may be between 8 and 10 files generated with
  // this prefix depending on how the index is constructed. The parent directory of this file must have write
  // permission. required
  // string index_path_prefix = 9;
}

message VectorNewResponse {
  // response info
  dingodb.pb.common.ResponseInfo response_info = 1;
  // error code
  dingodb.pb.error.Error error = 2;
}

message VectorPushDataRequest {
  dingodb.pb.common.RequestInfo request_info = 1;

  // vector index ID is equivalent to region_id
  int64 vector_index_id = 2;

  // vector data
  repeated dingodb.pb.common.Vector vectors = 3;

  // vector id
  repeated int64 vector_ids = 4;

  // Is there any data behind. ture : has data ; false : no data
  bool has_more = 5;

  // If an error occurs, cancel this round of data transmission.
  dingodb.pb.error.Error error = 6;

  // If true, force to load data even if file already exist.
  bool force_to_load_data_if_exist = 7;

  // The number of vectors already sent in this round of data transmission. (Not including this)
  int64 already_send_vector_count = 8;
}

message VectorPushDataResponse {
  // response info
  dingodb.pb.common.ResponseInfo response_info = 1;
  // error code
  dingodb.pb.error.Error error = 2;

  // The number of vectors already sent in this round of data transmission.
  int64 already_send_vector_count = 3;
}

message VectorBuildRequest {
  dingodb.pb.common.RequestInfo request_info = 1;

  // vector index ID is equivalent to region_id
  int64 vector_index_id = 2;

  // If true, force to build even if file already exist.
  bool force_to_build_if_exist = 3;  // if true, force to build even if file already exist.
}

message VectorBuildResponse {
  // response info
  dingodb.pb.common.ResponseInfo response_info = 1;
  // error code
  dingodb.pb.error.Error error = 2;
}

message VectorLoadRequest {
  dingodb.pb.common.RequestInfo request_info = 1;

  // vector index ID is equivalent to region_id
  int64 vector_index_id = 2;

  dingodb.pb.common.LoadDiskAnnParam load_param = 3;
}

message VectorLoadResponse {
  // response info
  dingodb.pb.common.ResponseInfo response_info = 1;
  // error code
  dingodb.pb.error.Error error = 2;
}

message VectorTryLoadRequest {
  dingodb.pb.common.RequestInfo request_info = 1;

  // vector index ID is equivalent to region_id
  int64 vector_index_id = 2;

  dingodb.pb.common.LoadDiskAnnParam load_param = 3;
}

message VectorTryLoadResponse {
  // response info
  dingodb.pb.common.ResponseInfo response_info = 1;
  // error code
  dingodb.pb.error.Error error = 2;
}

message VectorSearchRequest {
  dingodb.pb.common.RequestInfo request_info = 1;
  // vector index ID is equivalent to region_id
  int64 vector_index_id = 2;

  uint32 top_n = 3;

  dingodb.pb.common.SearchDiskAnnParam search_param = 4;

  repeated dingodb.pb.common.Vector vectors = 5;
}

message VectorSearchResponse {
  // response info
  dingodb.pb.common.ResponseInfo response_info = 1;
  // error code
  dingodb.pb.error.Error error = 2;
  repeated dingodb.pb.index.VectorWithDistanceResult batch_results = 3;
}

// Resets this object to its state before loading data.
message VectorResetRequest {
  dingodb.pb.common.RequestInfo request_info = 1;
  // vector index ID is equivalent to region_id
  int64 vector_index_id = 2;
  // If true, delete data file after reset.
  bool delete_data_file = 3;
}

message VectorResetResponse {
  // response info
  dingodb.pb.common.ResponseInfo response_info = 1;
  // error code
  dingodb.pb.error.Error error = 2;
}

message VectorCloseRequest {
  dingodb.pb.common.RequestInfo request_info = 1;
  int64 vector_index_id = 2;
}

message VectorCloseResponse {
  // response info
  dingodb.pb.common.ResponseInfo response_info = 1;
  // error code
  dingodb.pb.error.Error error = 2;
}

message VectorDestroyRequest {
  dingodb.pb.common.RequestInfo request_info = 1;
  int64 vector_index_id = 2;
}

message VectorDestroyResponse {
  // response info
  dingodb.pb.common.ResponseInfo response_info = 1;
  // error code
  dingodb.pb.error.Error error = 2;
}

message VectorStatusRequest {
  dingodb.pb.common.RequestInfo request_info = 1;
  int64 vector_index_id = 2;
}

message VectorStatusResponse {
  // response info
  dingodb.pb.common.ResponseInfo response_info = 1;
  // error code
  dingodb.pb.error.Error error = 2;

  dingodb.pb.common.DiskANNCoreState state = 3;
}

message VectorDumpRequest {
  dingodb.pb.common.RequestInfo request_info = 1;
  int64 vector_index_id = 2;
}

message VectorDumpResponse {
  // response info
  dingodb.pb.common.ResponseInfo response_info = 1;
  // error code
  dingodb.pb.error.Error error = 2;

  string dump_data = 3;
}

service DiskAnnService {
  // vector index
  rpc VectorNew(VectorNewRequest) returns (VectorNewResponse);
  rpc VectorPushData(VectorPushDataRequest) returns (VectorPushDataResponse);
  rpc VectorBuild(VectorBuildRequest) returns (VectorBuildResponse);
  rpc VectorLoad(VectorLoadRequest) returns (VectorLoadResponse);
  rpc VectorTryLoad(VectorTryLoadRequest) returns (VectorTryLoadResponse);
  rpc VectorSearch(VectorSearchRequest) returns (VectorSearchResponse);
  rpc VectorReset(VectorResetRequest) returns (VectorResetResponse);
  rpc VectorClose(VectorCloseRequest) returns (VectorCloseResponse);
  rpc VectorDestroy(VectorDestroyRequest) returns (VectorDestroyResponse);
  rpc VectorStatus(VectorStatusRequest) returns (VectorStatusResponse);

  // debug
  rpc VectorDump(VectorDumpRequest) returns (VectorDumpResponse);
}
